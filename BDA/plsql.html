
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PL/SQL</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<header id="arriba">
    <h1>Bases de datos</h1>
    <nav>
        <ul>
            <li><a href="./index.html">Presentaci√≥n</a></li>
            <li><a href="./almacenamiento.html">Almacenamiento</a></li>
            <li><a href="./logico.html">Dise√±o l√≥gico</a></li>
            <li><a href="./dcl.html">DCL TCL</a></li>
            <li><a href="./plsql.html">PL/SQL</a></li>
        </ul>
    </nav>
</header>
<main>
<section>
    <h2>Introducci√≥n a PL/SQL</h2>
    <p>El PL/SQL es un lenguaje de programaci√≥n de bases de datos. Este lenguaje permite incorporar todas las caracter√≠sticas propias de los lenguajes de tercera generaci√≥n: variables, estructura modular (procedimientos y funciones), estructuras de control (condicionales, bucles y dem√°s estructuras), control de errores, y una total integraci√≥n en el entorno Oracle. PL/SQL soporta todos los comandos de consulta y manipulaci√≥n de datos.</p>
    <p>Los programas realizados en PL/SQL se almacenan como cualquier otro objeto en la base de datos. Como si fueran cualquier otro objeto. Estos programas se ejecutan en el servidor, suponiendo una disminuci√≥n del tr√°fico de red y un ahorro de recursos.</p>
    <p>Con PL/SQL vamos a poder programar:</p>
    <ul>
        <li>Procedimientos almacenados</li>
        <li>Funciones</li>
        <li>Triggers</li>
        <li>Scripts</li>
    </ul>
</section>

<section>
    <h2>Primeros pasos con PL/SQL</h2>
    <ul>
        <li>El PL/SQL no es CASE-SENSITIVE, es decir, no diferencia may√∫sculas de min√∫sculas como otros lenguajes de programaci√≥n como C o Java. Sin embargo, ORACLE s√≠ lo es en las b√∫squedas de texto.</li>
        <li>IDENTIFICADORES: Se utilizan para nombrar los objetos en los programas PL/SQL como constantes, cursores, variables, excepciones, etc.</li>
        <li>Deben cumplir las siguientes caracter√≠sticas:
            <ul>
                <li>Pueden tener entre 1 y 30 caracteres de longitud.</li>
                <li>El primer car√°cter debe ser una letra.</li>
                <li>Los restantes caracteres deben ser alfanum√©ricos o signos admitidos (letras, d√≠gitos, almohadilla, subgui√≥n o signo del d√≥lar).</li>
            </ul>
        </li>
        <li>Las instrucciones PL/SQL terminan con un punto y coma (;), excepto algunas instrucciones como BEGIN, DECLARE, etc.</li>
        <li>Los comentarios:
            <ul>
                <li>de una l√≠nea se inician con <code>--</code></li>
                <li>los de varias l√≠neas inician con <code>/*</code> y terminan con <code>*/</code></li>
            </ul>
        </li>
    </ul>
</section>

<section>
    <h2>Bloques PL/SQL</h2>
    <p>El bloque es la estructura b√°sica que sigue un programa PL/SQL. En los bloques podemos diferenciar tres partes:</p>
    <pre>
[DECLARE
    Declaraci√≥n de variables] /*Parte declarativa*/
BEGIN
    Sentencias SQL y PL/SQL /*Parte de ejecuci√≥n*/
[EXCEPTION
    Manejadores de excepciones] /*Parte de excepciones*/
END;
    </pre>
    <p>En PL/SQL se pueden escribir cuatro tipos de bloques de c√≥digo:</p>
    <ul>
        <li>Bloques an√≥nimos</li>
        <li>Procedimientos</li>
        <li>Funciones</li>
        <li>Triggers</li>
    </ul>
</section>

<section>
    <h2>Tipos de datos PL/SQL</h2>
    <p>Las variables y constantes almacenan diferentes tipos de datos, similares a los soportados por SQL.</p>
    <ul>
        <li><strong>Car√°cter:</strong> CHAR(n), VARCHAR2(n), LONG(n)</li>
        <li><strong>Num√©ricos:</strong> NUMBER(P,E), PLS_INTEGER, FLOAT(n)</li>
        <li><strong>Fecha / Hora:</strong> DATE, TIMESTAMP, INTERVAL</li>
        <li><strong>Booleano:</strong> BOOLEAN</li>
        <li><strong>Otros:</strong> RAW(n), LONG RAW, BLOB, CLOB, ROWID, BFILE</li>
    </ul>
</section>

<section>
    <h2>Atributos de tipo: %TYPE y %ROWTYPE</h2>
    <p>Estos atributos permiten declarar variables que adopten autom√°ticamente el tipo de datos de columnas de una tabla o vista.</p>

    <h3>%TYPE</h3>
    <p>Se usa para declarar una variable con el mismo tipo que una columna de una tabla.</p>
    <pre>
-- Supongamos que existe una tabla PRODUCTOS con una columna PRECIO
DECLARE
    v_precio PRODUCTOS.PRECIO%TYPE;
BEGIN
    v_precio := 19.99;
    DBMS_OUTPUT.PUT_LINE('Precio: ' || v_precio);
END;
    </pre>

    <h3>%ROWTYPE</h3>
    <p>Se usa para declarar una variable que representa toda una fila de una tabla, con una variable por cada columna.</p>
    <pre>
-- Supongamos que existe una tabla EMPLEADOS con varias columnas
DECLARE
    v_empleado EMPLEADOS%ROWTYPE;
BEGIN
    SELECT * INTO v_empleado FROM EMPLEADOS WHERE ID = 1;
    DBMS_OUTPUT.PUT_LINE('Nombre: ' || v_empleado.NOMBRE);
END;
    </pre>
    <p>Es muy √∫til cuando necesitamos trabajar con registros completos de tablas.</p>
</section>


<section>
    <h2>Declaraci√≥n de variables y constantes</h2>
    <pre>
precio NUMBER (6,2):=0;
salario NUMBER (10,2);
ciudad VARCHAR2(20) NOT NULL DEFAULT 'Barcelona';
departamento CHAR(15) DEFAULT 'Ventas';

pvp producto.precio%TYPE;
persona trabajadores%ROWTYPE;

iva CONSTANT NUMBER(4,2) := 21;
    </pre>
</section>

<section>
    <h2>Interacci√≥n con el usuario</h2>
    <p>Para visualizar datos:</p>
    <pre>DBMS_OUTPUT.PUT_LINE(&lt;expresi√≥n&gt;);</pre>
    <p>Para recoger valores:</p>
    <pre>
SET SERVEROUTPUT ON;
DECLARE
edad BINARY_INTEGER := &edad;
nombre VARCHAR2(20) := '&nombre';
BEGIN
    dbms_output.put_line('Hola ' || nombre);
    dbms_output.put_line('Tienes ' || edad || ' a√±os');
END;
    </pre>
    <p>Evitar mensajes de verificaci√≥n:</p>
    <code>SET VERIFY OFF</code>
</section>

<section>
    <h2>Estructuras de control</h2>
    <h3>IF simple</h3>
    <pre>
IF condici√≥n THEN
    instrucciones;
END IF;
    </pre>

    <h3>IF-ELSE</h3>
    <pre>
IF condici√≥n THEN
    instrucciones;
ELSE
    instrucciones;
END IF;
    </pre>

    <h3>IF m√∫ltiple</h3>
    <pre>
IF condici√≥n1 THEN
    instrucciones;
ELSIF condici√≥n2 THEN
    instrucciones;
ELSE
    instrucciones;
END IF;
    </pre>

    <h3>Ejemplo con IF</h3>
    <pre>
SET SERVEROUTPUT ON;
SET VERIFY OFF;
accept numero prompt 'Escribe un n√∫mero: ';
DECLARE
numero BINARY_INTEGER := &numero;
BEGIN
IF (numero>=0) THEN
    dbms_output.put_line('Es positivo ' || numero);
ELSE
    dbms_output.put_line('Es negativo ' || numero);
END IF;
END;
    </pre>

    <h3>CASE</h3>
    <pre>
DECLARE
salario NUMBER(6,2);
departamento VARCHAR2(20) := '&departamento';
BEGIN
CASE departamento
WHEN 'ventas' THEN salario:=1300;
WHEN 'comercial' THEN salario:=1200;
ELSE salario:=1000;
END CASE;
dbms_output.put_line('Salario: ' || salario);
END;
    </pre>
</section>

<section>
    <h2>üìù Ejercicios propuestos</h2>
    <ol>
        <li>
            Crea un bloque PL/SQL que declare una constante con el valor del IVA (21%) y calcule el precio final de un producto a partir de un precio base introducido por el usuario.
        </li>
        <li>
            Crea un bloque que pida al usuario su edad y muestre un mensaje indicando si es mayor de edad o no.
        </li>
        <li>
            Declara una variable usando <strong>TYPE</strong> para copiar el tipo de una columna de una tabla de tu base de datos, as√≠gnale un valor y mu√©stralo con <strong>DBMS_OUTPUT.PUT_LINE</strong>.
        </li>
        <li>
            Usa un bucle <strong>FOR</strong> para mostrar los 10 primeros n√∫meros pares.
        </li>
        <li>
            Declara una variable de tipo <strong>%ROWTYPE</strong> para una tabla con varias columnas, realiza una consulta <strong>SELECT INTO</strong> y muestra por consola el contenido de al menos dos campos.
        </li>
    </ol>
</section>

<section>
<h2>Bucles en PL/SQL</h2>
<p>Un bucle es una estructura de control que permite ejecutar un conjunto de instrucciones de forma repetitiva hasta que se cumpla una condici√≥n. Son muy √∫tiles para automatizar procesos repetitivos.</p>
<p>PL/SQL dispone de tres tipos principales de bucles:</p>
<h3>LOOP</h3>
<p>Es el bucle m√°s b√°sico. Se ejecuta indefinidamente y debe contener una condici√≥n expl√≠cita de salida con <strong>EXIT</strong> o <strong>EXIT WHEN</strong>. Es ideal cuando queremos tener un control total sobre cu√°ndo se debe salir del bucle.</p>
<pre><code>DECLARE
  i NUMBER := 1;
BEGIN
  LOOP
    DBMS_OUTPUT.PUT_LINE('Valor: ' || i);
    i := i + 1;
    EXIT WHEN i &gt; 5;
  END LOOP;
END;
/
</code></pre>
<h3>WHILE LOOP</h3>
<p>Eval√∫a la condici√≥n antes de ejecutar el bloque. Si la condici√≥n es falsa desde el inicio, el bloque no se ejecuta. Es √∫til cuando no sabemos cu√°ntas iteraciones se van a realizar, pero depende de una condici√≥n din√°mica.</p>
<pre><code>DECLARE
  i NUMBER := 1;
BEGIN
  WHILE i &lt;= 5 LOOP
    DBMS_OUTPUT.PUT_LINE('Contador: ' || i);
    i := i + 1;
  END LOOP;
END;
/
</code></pre>
<h3>FOR LOOP</h3>
<p>Recorre autom√°ticamente un rango de valores. Es el bucle m√°s compacto y adecuado cuando conocemos el n√∫mero exacto de iteraciones. La variable de control se crea y destruye autom√°ticamente dentro del bucle.</p>
<pre><code>BEGIN
  FOR i IN 1..5 LOOP
    DBMS_OUTPUT.PUT_LINE('Iteraci√≥n: ' || i);
  END LOOP;
END;
/
</code></pre>
<h4>Resumen de uso:</h4>
<ul>
<li><strong>LOOP:</strong> Para iteraciones donde se necesita control manual y condicional.</li>
<li><strong>WHILE:</strong> Para condiciones que pueden no cumplirse desde el principio.</li>
<li><strong>FOR:</strong> Para bucles con rangos definidos de antemano.</li>
</ul>
</section>
<section>
<h2>Cursores en PL/SQL</h2>
<p>Los cursores son estructuras que nos permiten recorrer, fila a fila, el resultado de una consulta SQL. Son muy √∫tiles cuando trabajamos con m√∫ltiples filas y necesitamos procesarlas individualmente en PL/SQL.</p>
<h3>Tipos de cursores</h3>
<ul>
<li><strong>Cursores impl√≠citos:</strong> PL/SQL los gestiona autom√°ticamente con instrucciones como <strong>SELECT INTO</strong>.</li>
<li><strong>Cursores expl√≠citos:</strong> Declarados por el programador, permiten mayor control.</li>
</ul>
<h3>Operaciones fundamentales con cursores expl√≠citos</h3>
<ul>
<li><strong>OPEN</strong>: ejecuta la consulta y abre el cursor.</li>
<li><strong>FETCH</strong>: recupera una fila del resultado y la guarda en variables.</li>
<li><strong>CLOSE</strong>: cierra el cursor y libera recursos.</li>
</ul>
<p>Ejemplo con control manual:</p>
<pre><code>DECLARE
  CURSOR cur_emp IS SELECT nombre, salario FROM empleados;
  v_nom empleados.nombre%TYPE;
  v_sal empleados.salario%TYPE;
BEGIN
  OPEN cur_emp;
  LOOP
    FETCH cur_emp INTO v_nom, v_sal;
    EXIT WHEN cur_emp%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_nom || ': ' || v_sal);
  END LOOP;
  CLOSE cur_emp;
END;
/
</code></pre>
<h3>Cursores con FOR</h3>
<p>PL/SQL gestiona autom√°ticamente apertura, lectura y cierre. Ideal para procesos simples.</p>
<pre><code>BEGIN
  FOR emp IN (SELECT nombre, salario FROM empleados) LOOP
    DBMS_OUTPUT.PUT_LINE(emp.nombre || ': ' || emp.salario);
  END LOOP;
END;
/
</code></pre>
<h3>Relaci√≥n con excepciones</h3>
<p>Cuando usamos <strong>SELECT INTO</strong> directamente, se lanzan excepciones si no se encuentra ninguna fila (<strong>NO_DATA_FOUND</strong>) o si se encuentran m√∫ltiples (<strong>TOO_MANY_ROWS</strong>). Con cursores, usamos los atributos <strong>%FOUND</strong>, <strong>%NOTFOUND</strong> y <strong>%ROWCOUNT</strong> para controlar el flujo sin necesidad de excepciones.</p>
<p>Ejemplo con SELECT INTO:</p>
<pre><code>BEGIN
  SELECT nombre INTO v_nombre FROM empleados WHERE id = 999;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('No se encontr√≥ ning√∫n empleado.');
END;
/
</code></pre>
</section>
<section>
<h2>Procedimientos y Funciones</h2>
<p>Los procedimientos y funciones permiten encapsular bloques de c√≥digo reutilizables. Son fundamentales para organizar el c√≥digo y separar responsabilidades.</p>
<h3>Procedimientos</h3>
<p>Un procedimiento ejecuta acciones, pero no devuelve directamente un valor. Puede recibir par√°metros de entrada y salida.</p>
<pre><code>CREATE OR REPLACE PROCEDURE saludar(nombre IN VARCHAR2) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hola, ' || nombre);
END;
/
BEGIN
  saludar('Ana');
END;
/
</code></pre>
<h3>Funciones</h3>
<p>Una funci√≥n realiza c√°lculos y devuelve un valor. Puede ser usada en expresiones SQL, SELECT, etc.</p>
<pre><code>CREATE OR REPLACE FUNCTION doble(n IN NUMBER) RETURN NUMBER IS
BEGIN
  RETURN n * 2;
END;
/
BEGIN
  DBMS_OUTPUT.PUT_LINE('Doble de 5: ' || doble(5));
END;
/
</code></pre>

</section>

<h2>Triggers en PL/SQL</h2>
<p>
    Un <strong>trigger</strong> (o disparador) es un bloque de c√≥digo PL/SQL que se ejecuta de forma <strong>autom√°tica</strong> cuando ocurre un evento concreto sobre una tabla o vista. Este evento puede ser una operaci√≥n de <strong>INSERT</strong>, <strong>UPDATE</strong> o <strong>DELETE</strong>.
  </p>
<p>
    Los triggers se utilizan para <strong>automatizar tareas</strong>, <strong>implementar reglas de negocio</strong> o <strong>mantener la integridad de los datos</strong> sin necesidad de que el usuario o desarrollador los invoque expl√≠citamente.
  </p>
<h3>¬øCu√°ndo se ejecutan?</h3>
<ul>
<li><strong>BEFORE:</strong> antes de que se realice la operaci√≥n sobre los datos.</li>
<li><strong>AFTER:</strong> despu√©s de que se haya realizado la operaci√≥n.</li>
</ul>
<h3>¬øSobre qu√© operaciones pueden actuar?</h3>
<ul>
<li><strong>INSERT</strong>: cuando se insertan nuevos registros.</li>
<li><strong>UPDATE</strong>: cuando se modifican registros existentes.</li>
<li><strong>DELETE</strong>: cuando se eliminan registros.</li>
</ul>
<h3>¬øQu√© tipos de triggers existen?</h3>
<ul>
<li><strong>Row-level (por fila):</strong> se ejecutan una vez por cada fila afectada (<strong>FOR EACH ROW</strong>).</li>
<li><strong>Statement-level (por sentencia):</strong> se ejecutan una sola vez, aunque la operaci√≥n afecte a m√∫ltiples filas.</li>
</ul>
<h3>¬øPor qu√© usar triggers?</h3>
<ul>
<li>Para <strong>validar datos</strong> antes de que se inserten o modifiquen.</li>
<li>Para <strong>registrar cambios</strong> autom√°ticamente (auditor√≠a).</li>
<li>Para <strong>actualizar o sincronizar</strong> datos en otras tablas.</li>
<li>Para <strong>impedir ciertas operaciones</strong> no deseadas.</li>
</ul>
<h3>Sintaxis general</h3>
<pre><strong>CREATE OR REPLACE TRIGGER nombre_trigger
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON nombre_tabla
[FOR EACH ROW]
DECLARE
  -- Declaraciones opcionales
BEGIN
  -- C√≥digo PL/SQL que se ejecuta autom√°ticamente
END;
/
</strong></pre>
<h3>Variables especiales en triggers de fila</h3>
<ul>
<li><strong>:OLD</strong>: contiene los valores anteriores de la fila (antes del cambio).</li>
<li><strong>:NEW</strong>: contiene los valores nuevos que se quieren insertar o actualizar.</li>
</ul>
<h3>Ejemplo 1: Impedir que se reduzca el salario</h3>
<p>Trigger que evita que se actualice un salario si el nuevo valor es inferior al anterior.</p>
<pre><strong>CREATE OR REPLACE TRIGGER trg_no_salario_menor
BEFORE UPDATE OF salary ON employees
FOR EACH ROW
BEGIN
  IF :NEW.salary &lt; :OLD.salary THEN
    RAISE_APPLICATION_ERROR(-20001, 'No se permite reducir el salario.');
  END IF;
END;
/
</strong></pre>
<h3>Ejemplo 2: Registrar auditor√≠a de eliminaci√≥n</h3>
<p>Creamos una tabla auxiliar <strong>empleados_borrados</strong> y usamos un trigger para registrar autom√°ticamente los datos de cualquier empleado que sea eliminado.</p>
<pre><strong>CREATE TABLE empleados_borrados (
  id NUMBER,
  nombre VARCHAR2(100),
  fecha_borrado DATE
);

CREATE OR REPLACE TRIGGER trg_auditoria_borrado
AFTER DELETE ON employees
FOR EACH ROW
BEGIN
  INSERT INTO empleados_borrados(id, nombre, fecha_borrado)
  VALUES (:OLD.employee_id, :OLD.first_name || ' ' || :OLD.last_name, SYSDATE);
END;
/
</strong></pre>
<h3>Ejemplo 3: Ajustar salario al cambiar el puesto</h3>
<p>Si se cambia el <strong>job_id</strong> de un empleado, el trigger ajusta su salario autom√°ticamente en un 5%.</p>
<pre><strong>CREATE OR REPLACE TRIGGER trg_bonus_por_puesto
BEFORE UPDATE OF job_id ON employees
FOR EACH ROW
BEGIN
  :NEW.salary := :NEW.salary * 1.05;
END;
/
</strong></pre>

</section>

<a href="#arriba" class="back-to-top">‚Üë</a>



</main>
<footer>
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
        <img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="Licencia Creative Commons">
    </a>
</footer>
</body>
</html>
