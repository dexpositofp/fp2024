<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diseño lógico de bases de datos</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Header común para todas las páginas -->
    <header id="arriba">
        <h1>Bases de datos</h1>
        <nav>
            <ul>
                <li><a href="./index.html">Presentación</a></li>
                <li><a href="./almacenamiento.html">Almacenamiento</a></li>
                <li><a href="./logico.html">Diseño lógico</a></li>
                <!--<li><a href="./fisico.html">Diseño físico</a></li>
                <li><a href="./ddl.html">DDL</a></li>
                <li><a href="./dml.html">DML</a></li> -->
                <li><a href="./dcl.html">DCL TCL</a></li>
              <!--  <li><a href="./utilidades.html">Utilidades</a></li>
                <li><a href="./plsql.html">PL/SQL</a></li>
                <li><a href="./nosql.html">NoSQL</a></li>-->
            </ul>
        </nav>
    </header>

    <main>


<section id="introduccion-logico">
    <h2>Diseño Lógico de Bases de Datos</h2>
    <p>El diseño lógico de una base de datos es un paso crucial en el desarrollo de un sistema de bases de datos. Consiste en transformar los requisitos de información de una organización, que inicialmente se representan de manera abstracta, en una estructura lógica que pueda implementarse en un sistema de gestión de bases de datos (SGBD).</p>

    <p>En esta etapa, se parte de un modelo conceptual (generalmente, un diagrama Entidad-Relación, también conocido como E/R) que describe la información y las relaciones entre los distintos elementos de un sistema, y se transforma en un modelo lógico que sigue las reglas del modelo de datos que se va a utilizar. El diseño lógico suele realizarse bajo un enfoque relacional, ya que las bases de datos relacionales son las más comunes, pero también puede aplicarse a otros modelos como el jerárquico o en red.</p>

    <h3>Objetivos del Diseño Lógico</h3>
    <ul>
        <li>Definir de manera precisa las tablas que representarán los datos.</li>
        <li>Establecer las relaciones entre las tablas mediante claves foráneas y restricciones.</li>
        <li>Optimizar la estructura de la base de datos para mejorar el rendimiento.</li>
        <li>Garantizar que la base de datos sea flexible, escalable y fácil de mantener.</li>
    </ul>

    <h3>Pasos en el Diseño Lógico</h3>
    <p>El diseño lógico de una base de datos sigue una serie de pasos clave:</p>
    <ol>
        <li><strong>Modelado conceptual:</strong> Consiste en la creación de un modelo que represente los elementos y relaciones del sistema de manera abstracta. Aquí se utilizan herramientas como los diagramas E/R.</li>
        <li><strong>Transformación a modelo lógico:</strong> El diagrama E/R se convierte en un modelo de base de datos que puede implementarse en un SGBD. En el caso de bases de datos relacionales, esto implica la creación de tablas, columnas, claves primarias y claves foráneas.</li>
        <li><strong>Normalización:</strong> Se aplica un proceso de normalización para eliminar redundancias y asegurar la integridad de los datos.</li>
        <li><strong>Validación y optimización:</strong> Finalmente, se revisa y optimiza el modelo lógico para garantizar que cumpla con los requisitos de rendimiento y escalabilidad.</li>
    </ol>

    <h3>El Diagrama Entidad-Relación (E/R)</h3>
    <p>Uno de los componentes fundamentales en el diseño lógico de una base de datos es el diagrama Entidad-Relación (E/R). Este diagrama permite representar gráficamente las entidades (objetos) que componen el sistema y las relaciones que existen entre ellas. A partir de este diagrama conceptual, el diseñador de bases de datos puede pasar al modelo relacional, que es más formal y que puede ser implementado en un SGBD relacional.</p>

    <p>El diagrama E/R proporciona una forma clara y concisa de visualizar cómo los diferentes elementos de un sistema interactúan entre sí, lo que facilita el proceso de diseño lógico y posterior implementación.</p>
</section>

<section id="diagrama-er">
    <h2>Diagrama Entidad-Relación (E/R)</h2>
    <p>El diagrama Entidad-Relación (E/R) es una herramienta fundamental en el diseño conceptual de bases de datos. Representa de manera gráfica las entidades, atributos y las relaciones que existen entre ellas en el sistema que se desea modelar. A continuación, se describen los componentes más importantes de un diagrama E/R.</p>

    <h3>Componentes del Diagrama E/R</h3>

    <h4>1. Entidades</h4>
    <p>Las entidades son objetos o conceptos del mundo real que tienen una existencia independiente. En el contexto de una base de datos, una entidad se representa como un rectángulo y puede ser cualquier cosa sobre la que necesitamos almacenar información, como personas, productos o eventos.</p>
    <ul>
        <li>Ejemplo: Una entidad <span class="resaltar">Cliente</span> en un sistema de ventas.</li>
    </ul>

    <img class="centrar" src="./img/entidad.png"></img>

    <h4>2. Atributos</h4>
    <p>Los atributos describen propiedades o características de las entidades. En el diagrama, se representan con óvalos conectados a su entidad correspondiente. Algunos atributos son clave, lo que significa que son únicos para cada entidad.</p>
    <p>Los atributos pueden clasificarse en diferentes tipos:</p>
            <ul>
                <li><strong>Atributos monovaluados:</strong> Contienen un solo valor para cada entidad. Ejemplo: el <em>nombre</em> de una persona.</li>
                <li><strong>Atributos multivaluados:</strong> Pueden contener múltiples valores para cada entidad. Ejemplo: los <em>teléfonos</em> de una persona.</li>
                <li><strong>Atributos compuestos:</strong> Son aquellos que pueden subdividirse en varios subatributos. Ejemplo: el <em>nombre completo</em>, que puede subdividirse en <em>nombre</em> y <em>apellido</em>.</li>
                <li><strong>Atributos opcionales:</strong> No son necesarios para cada entidad, es decir, pueden tener un valor o pueden estar vacíos. Ejemplo: el <em>segundo apellido</em> de una persona.</li>
            </ul>
    <ul>
        <li>Ejemplo: La entidad <span class="resaltar">Cliente</span> puede tener los atributos <span class="resaltar">Nombre</span>, <span class="resaltar">Dirección</span> y <span class="resaltar">Teléfono</span>.</li>
    </ul>
    
    <img class="centrar" src="./img/atributos.png"></img>

    <h4>3. Relaciones</h4>
    <p>Las relaciones describen cómo dos o más entidades están asociadas entre sí. Se representan con rombos conectados a las entidades que participan en la relación. Las relaciones pueden tener diferentes cardinalidades (uno a uno, uno a muchos, muchos a muchos), lo que indica cuántas instancias de una entidad pueden estar relacionadas con instancias de otra entidad.</p>
    <ul>
        <li>Ejemplo: Un <span class="resaltar">Cliente</span> realiza un <span class="resaltar">Pedido</span>, por lo que existe una relación entre las entidades <span class="resaltar">Cliente</span> y <span class="resaltar">Pedido</span>.</li>
    </ul>

    <h4>4. Cardinalidad</h4>
    <p>La cardinalidad de una relación define el número de instancias que pueden estar asociadas entre las entidades relacionadas. Existen varios tipos de cardinalidad:</p>
    <ul>
        <li><span class="resaltar">Uno a uno (1:1):</span> Una entidad de un conjunto está relacionada con una sola entidad de otro conjunto.</li>
        <li><span class="resaltar">Uno a muchos (1:N):</span> Una entidad de un conjunto puede estar relacionada con muchas entidades de otro conjunto, pero una entidad del otro conjunto solo puede estar relacionada con una del primero.</li>
        <li><span class="resaltar">Muchos a muchos (N:M):</span> Varias entidades de un conjunto pueden estar relacionadas con varias entidades del otro conjunto.</li>
    </ul>
    
    <img class="centrar" src="./img/cardinalidad.png"></img>

    <h4>5. Atributos Clave</h4>
    <p>Un atributo clave es aquel que identifica de forma única cada instancia de una entidad. Los atributos clave se representan en el diagrama con un subrayado.</p>
    <ul>
        <li>Ejemplo: En la entidad <span class="resaltar">Cliente</span>, el atributo <span class="resaltar">ID_Cliente</span> puede ser una clave primaria, ya que identifica de manera única a cada cliente.</li>
    </ul>

    <h4>6. Entidades Débiles</h4>
    <p>Una entidad débil es una entidad que no tiene una clave propia para identificarse de manera única y depende de la clave de otra entidad (entidad fuerte). Se representan con un doble rectángulo.</p>
    <ul>
        <li>Ejemplo: En un sistema de reserva de habitaciones de hotel, la entidad <span class="resaltar">Reserva</span> puede ser una entidad débil dependiente de la entidad <span class="resaltar">Habitación</span>.</li>
    </ul>

    <h4>4. Agregación y Especialización</h4>
            <p><strong>Agregación:</strong> Es un proceso mediante el cual una relación entre entidades se trata como una entidad.</p>
            <p><strong>Especialización:</strong> Se utiliza cuando una entidad general se subdivide en entidades más específicas. Ejemplo: Una entidad <em>Empleado</em> puede subdividirse en <em>Gerente</em> y <em>Operario</em>.</p>
        </section>

        <section id="ejercicios">
            <h2>Ejercicios</h2>
            <p>Identifica las entidades, atributos, relaciones, cardinalidades y tipos de atributos.</p>
            <h3>Ejercicio 1:</h3>
            <p>Un cliente realiza uno o varios pedidos en una tienda online. Cada pedido está relacionado con uno o más productos, y cada producto tiene un precio, nombre y descripción. Los pedidos se identifican mediante un número de pedido único y están asociados a una fecha.</p>

            <h3>Ejercicio 2:</h3>
            <p>Un profesor imparte una o varias asignaturas, y cada asignatura tiene un código, un título y un número de créditos. Los estudiantes pueden matricularse en varias asignaturas, y cada matrícula está identificada por un número único.</p>

            <h3>Ejercicio 3:</h3>
            <p>En una biblioteca, los libros están clasificados por género. Cada libro tiene un título, autor y un ISBN único. Un lector puede tomar prestados varios libros, y cada préstamo tiene una fecha de inicio y una fecha de finalización.</p>

            <h3>Ejercicio 4:</h3>
            <p>En un hospital, los doctores están especializados en diferentes áreas. Cada doctor tiene un identificador único, un nombre y un número de teléfono. Los pacientes pueden estar asignados a varios doctores, y cada paciente tiene un historial médico único.</p>

            <h3>Ejercicio 5:</h3>
            <p>Un equipo de fútbol está compuesto por jugadores que tienen un número de camiseta único, un nombre y una posición en el campo. Un entrenador entrena uno o más equipos, y cada equipo tiene un nombre y un identificador único.</p>
        </section>


        <section id="notacion-independiente">
    <h2>Notación Independiente del Modelo Físico</h2>
    <p>En el diseño de bases de datos, es esencial comprender cómo representar la información de manera efectiva. Usaremos la notación Demarco, que permite traducir un Diagrama Entidad-Relación (DER) a un esquema relacional. A continuación, se presentan los conceptos clave.</p>

    <h3>Modelos de Representación</h3>
    <p>El modelo ER representa el mundo mediante:</p>
    <ul>
        <li><strong>Entidades:</strong> fuertes y débiles.</li>
        <li><strong>Atributos:</strong> normales, identificantes, obligatorios, compuestos, multivaluados, etc.</li>
        <li><strong>Relaciones y restricciones:</strong> cardinalidad máxima (1-N) y mínima (0-1), identificantes, generalizaciones y agregaciones.</li>
        <li><strong>Aserciones:</strong> reglas de negocio.</li>
    </ul>
    <p>El modelo relacional utiliza otros mecanismos:</p>
    <ul>
        <li><strong>Tablas:</strong> se representan con columnas que contienen valores atómicos.</li>
        <li><strong>Restricciones:</strong>
            <ul>
                <li>Integridad: claves primarias y alternativas.</li>
                <li>Integridad referencial: claves ajenas.</li>
                <li>Valores no nulos.</li>
                <li>Restricciones de valores (tipos de datos y check) y aserciones.</li>
            </ul>
        </li>
    </ul>

    <h3>Notación Demarco</h3>
    <p>La notación Demarco se utiliza para expresar el esquema relacional y tiene las siguientes características:</p>
    <ul>
        <li><strong>T = col1 + ... + coln:</strong> define la tabla llamada T con el nombre de sus columnas.</li>
        <li><strong>CP(columnas):</strong> columnas que forman la clave primaria de la tabla T (una pk por tabla).</li>
        <li><strong>CAlt(columnas):</strong> columnas que forman una clave alternativa de T (0 o más por tabla).</li>
        <li><strong>C.Ajena(columnas) → T1(columnas1):</strong> clave ajena (referencia) a las columnas de la tabla T1, donde columnas1 es clave primaria o alternativa en T1 (0 o más por tabla).</li>
        <li><strong>VNN(columna):</strong> valor no nulo de columna.</li>
        <li><strong>ASERCIÓN n:</strong> una restricción o regla de negocio.</li>
    </ul>

    <h3>Entidades y Atributos</h3>
    <p>Casi siempre, toda entidad del modelo ER genera una tabla en el modelo relacional. Cada atributo de la entidad se corresponde con otro de la tabla. Pero hay casos especiales:</p>
    <ul>
        <li><span class="resaltar">Atributos compuestos:</span> el modelo relacional solo admite atributos atómicos (sin estructura). La tabla tendrá como columnas individuales los atributos que componen el atributo compuesto.</li>
        <li><span class="resaltar">Atributos multivaluados:</span> generan una nueva tabla, y su clave primaria es la de la entidad origen junto al atributo multivaluado (o como mínimo uno de ellos).</li>
        <li><span class="resaltar">Atributos obligatorios:</span> además de crear la columna, se indica VNN (atributo).</li>
        <li><span class="resaltar">Atributos derivados:</span> podría indicarse la fórmula con la que se calcula su valor.</li>
    </ul>


    <h3>Relaciones Binarias</h3>
    <p>Dependiendo de la cardinalidad de la relación, las entidades pueden generar o no tablas adicionales. A continuación, se muestran algunos ejemplos:</p>
    
    <h4>Relación Muchos a Muchos (N:M)</h4>
    <p>En una relación N:M, siempre se genera una tabla para la relación. Por ejemplo, un alumno puede estudiar varias asignaturas, y una asignatura puede tener varios alumnos.</p>
    <pre>
        Alumno = expediente, nombre
        CP(expediente)
        Asignatura = código, descripción
        CP(código)
        Notas = expediente, código, eval1, eval2, final
        CP(expediente, código)
    </pre>
    <p>La tabla Notas incluye como claves ajenas el expediente y el código de alumno y asignatura respectivamente.</p>

    <h4>Relación Uno a Uno (1:1)</h4>
    <p>En una relación 1:1, no se genera una tabla para la relación. En lugar de ello, se puede incluir la clave de una entidad como clave alternativa o ajena en la otra. Ejemplo: Un conductor puede conducir como máximo un coche, y un coche puede ser conducido como máximo por un conductor.</p>
    <pre>
        Conductor = dni, nombre
        CP(dni)
        Coche = matrícula, marca, coordenadasGPS, dni
        CP(matrícula)
        C.Alt(dni)
    </pre>

    <h4>Relación Uno a Muchos (1:N)</h4>
    <p>En una relación 1:N, tampoco se genera una tabla para la relación. La clave de la entidad con cardinalidad 1 se incluye como clave ajena en la tabla de la entidad del lado N. Ejemplo: Un departamento puede tener varios empleados.</p>
    <pre>
        Departamento = depto, nombre
        CP(depto)
        Empleado = dni, nombre, depto
        CP(dni)
        C.Aj(depto)
    </pre>
</section>

    <h3>Relaciones reflexivas</h3>
    <p>Las relaciones reflexivas son aquellas en las que una entidad se relaciona consigo misma. También pueden tener cardinalidades N:M, 1:1, o 1:N.</p>

    <h4>Relación Muchos a Muchos (N:N)</h4>
    <p>Un ejemplo sería el caso de los temas y subtemas en un videoclub. Un tema puede ser subtema de otros temas y a su vez tener muchos subtemas.</p>
    <pre>
        Tema = nombre, descripción
        CP(nombre)
        Relación = nombre, subtema
        CP(nombre, subtema)
    </pre>

    <h4>Relación Uno a Uno (1:1)</h4>
    <p>En una relación 1:1 unaria, un ejemplo clásico sería la relación de una persona casada con otra persona. Cada persona solo puede tener una pareja.</p>
    <pre>
        Persona = dni, nombre, pareja, fecha_casamiento
        CP(dni)
        C.Alt(pareja)
    </pre>

    <p>En una relación 1:N unaria, como un empleado que depende de un jefe, se puede modelar la dependencia de un empleado hacia un jefe en una organización.</p>
    <pre>
        Empleado = dni, nombre, jefe
        CP(dni)
        C.Aj(jefe)
    </pre>
</section>
    
   <section id="restricciones_existencialidad">
    <h3>Relaciones Binarias con Restricción de Existencialidad</h3>
    <p>Cuando la cardinalidad mínima es 1 en ambos lados de una relación binaria, se exige que las entidades de ambos lados estén totalmente relacionadas a través de la relación, es decir, que cada entidad debe estar asociada al menos con una entidad del otro conjunto.</p>
    
    <h4>Relación Muchos a Muchos (N:N) con Existencialidad Total</h4>
    <p>En una relación N:N con existencialidad total, siempre se genera una tabla para la relación, y se deben cumplir las siguientes aserciones para garantizar que todas las entidades de ambos conjuntos están relacionadas. Ejemplo: Un alumno debe estar matriculado en al menos una asignatura, y cada asignatura debe tener al menos un alumno.</p>
    <pre>
        Alumno = expediente, nombre
        CP(expediente)
        Asignatura = codigo, descripcion
        CP(codigo)
        Matricula = expediente, codigo, fecha
        CP(expediente, codigo)
        C.Aj(expediente) → Alumno
        C.Aj(codigo) → Asignatura

        ASERCIÓN 1: Asignatura[codigo] ⊆ Matricula[codigo]
        ASERCIÓN 2: Alumno[expediente] ⊆ Matricula[expediente]
    </pre>
    <p>La tabla <code>Matricula</code> incluye claves ajenas a <code>Alumno</code> y <code>Asignatura</code>, y las aserciones aseguran que cada alumno está matriculado en al menos una asignatura, y cada asignatura tiene al menos un alumno.</p>

    <h4>Relación Uno a Uno (1:1) con Existencialidad Total</h4>
    <p>En una relación 1:1 con existencialidad total, no se genera una tabla adicional, pero la clave de una entidad debe incluirse en la otra como clave alternativa o ajena. Ejemplo: Un empleado debe estar asignado a un escritorio, y cada escritorio debe estar asignado a un empleado.</p>
    <pre>
        Empleado = dni, nombre
        CP(dni)
        Escritorio = id_escritorio, ubicacion, dni
        CP(id_escritorio)
        C.Alt(dni) → Empleado

        ASERCIÓN 1: Escritorio[dni] ⊆ Empleado[dni]
        ASERCIÓN 2: Empleado[dni] ⊆ Escritorio[dni]
    </pre>
    <p>La clave <code>dni</code> en <code>Escritorio</code> referencia a la entidad <code>Empleado</code>, y las aserciones garantizan que cada empleado está asignado a un escritorio y cada escritorio tiene un empleado.</p>
</section>

<section id="relaciones_reflexivas_existencialidad">
    <h3>Relaciones Reflexivas con Restricción de Existencialidad</h3>
    <p>Una relación reflexiva con existencialidad total requiere que cada entidad esté relacionada consigo misma o con otra entidad del mismo conjunto. Un ejemplo típico podría ser la relación de supervisión entre empleados.</p>
    
    <h4>Relación Uno a Muchos (1:N) Reflexiva con Existencialidad Total</h4>
    <p>En una relación reflexiva 1:N, cada entidad debe estar relacionada con al menos una entidad del mismo conjunto. Ejemplo: Un empleado debe ser supervisado por otro empleado.</p>
    <pre>
        Empleado = dni, nombre, supervisor
        CP(dni)
        C.Aj(supervisor) → Empleado

        ASERCIÓN: Empleado[supervisor] ⊆ Empleado[dni]
    </pre>
    <p>La clave ajena <code>supervisor</code> hace referencia al mismo conjunto de empleados, y la aserción asegura que cada empleado tiene un supervisor.</p>
</section>



<section id="relaciones_reflexivas_existencialidad">
    <h3>Relaciones Reflexivas con Restricción de Existencialidad</h3>
    <p>Una relación reflexiva con existencialidad total requiere que cada entidad esté relacionada consigo misma o con otra entidad del mismo conjunto. Un ejemplo típico podría ser la relación de supervisión entre empleados.</p>
    
    <h4>Relación Uno a Muchos (1:N) Reflexiva con Existencialidad Total</h4>
    <p>En una relación reflexiva 1:N, cada entidad debe estar relacionada con al menos una entidad del mismo conjunto. Ejemplo: Un empleado debe ser supervisado por otro empleado.</p>
    <pre>
        Empleado = dni, nombre, supervisor
        CP(dni)
        C.Aj(supervisor) → Empleado

        ASERCIÓN: Empleado[supervisor] ⊆ Empleado[dni]
    </pre>
    <p>La clave ajena <code>supervisor</code> hace referencia al mismo conjunto de empleados, y la aserción asegura que cada empleado tiene un supervisor.</p>
</section>

<section id="relaciones_reflexivas_existencialidad">
    <h3>Relaciones Reflexivas con Restricción de Existencialidad</h3>
    <p>Una relación reflexiva con existencialidad total requiere que cada entidad esté relacionada consigo misma o con otra entidad del mismo conjunto. Un ejemplo típico podría ser la relación de supervisión entre empleados.</p>
    
    <h4>Relación Uno a Muchos (1:N) Reflexiva con Existencialidad Total</h4>
    <p>En una relación reflexiva 1:N, cada entidad debe estar relacionada con al menos una entidad del mismo conjunto. Ejemplo: Un empleado debe ser supervisado por otro empleado.</p>
    <pre>
        Empleado = dni, nombre, supervisor
        CP(dni)
        C.Aj(supervisor) → Empleado

        ASERCIÓN: Empleado[supervisor] ⊆ Empleado[dni]
    </pre>
    <p>La clave ajena <code>supervisor</code> hace referencia al mismo conjunto de empleados, y la aserción asegura que cada empleado tiene un supervisor.</p>
</section>

<section id="relaciones_reflexivas_existencialidad">
    <h3>Relaciones Reflexivas con Restricción de Existencialidad</h3>
    <p>Una relación reflexiva con existencialidad total requiere que cada entidad esté relacionada consigo misma o con otra entidad del mismo conjunto. Un ejemplo típico podría ser la relación de supervisión entre empleados.</p>
    
    <h4>Relación Uno a Muchos (1:N) Reflexiva con Existencialidad Total</h4>
    <p>En una relación reflexiva 1:N, cada entidad debe estar relacionada con al menos una entidad del mismo conjunto. Ejemplo: Un empleado debe ser supervisado por otro empleado.</p>
    <pre>
        Empleado = dni, nombre, supervisor
        CP(dni)
        C.Aj(supervisor) → Empleado

        ASERCIÓN: Empleado[supervisor] ⊆ Empleado[dni]
    </pre>
    <p>La clave ajena <code>supervisor</code> hace referencia al mismo conjunto de empleados, y la aserción asegura que cada empleado tiene un supervisor.</p>
</section>

<section id="relaciones_reflexivas_existencialidad">
    <h3>Relaciones Reflexivas con Restricción de Existencialidad</h3>
    <p>Una relación reflexiva con existencialidad total requiere que cada entidad esté relacionada consigo misma o con otra entidad del mismo conjunto. Un ejemplo típico podría ser la relación de supervisión entre empleados.</p>
    
    <h4>Relación Uno a Muchos (1:N) Reflexiva con Existencialidad Total</h4>
    <p>En una relación reflexiva 1:N, cada entidad debe estar relacionada con al menos una entidad del mismo conjunto. Ejemplo: Un empleado debe ser supervisado por otro empleado.</p>
    <pre>
        Empleado = dni, nombre, supervisor
        CP(dni)
        C.Aj(supervisor) → Empleado

        ASERCIÓN: Empleado[supervisor] ⊆ Empleado[dni]
    </pre>
    <p>La clave ajena <code>supervisor</code> hace referencia al mismo conjunto de empleados, y la aserción asegura que cada empleado tiene un supervisor.</p>
</section>
<section id="relaciones_ternarias_existencialidad">
    <h3>Relaciones Ternarias con Restricción de Existencialidad</h3>
    <p>En las relaciones ternarias con existencialidad total, todas las entidades involucradas deben participar en la relación, es decir, cada entidad de los tres conjuntos debe estar relacionada al menos una vez.</p>
    
    <h4>Relación N:M:P con Existencialidad Total</h4>
    <p>En una relación N:M:P, siempre se genera una tabla para la relación que incluye las claves de las tres entidades, además de las aserciones necesarias. Ejemplo: Un producto debe ser suministrado por un proveedor a través de un contrato, y cada contrato debe involucrar a un producto y un proveedor.</p>
    <pre>
        Producto = id_producto, nombre_producto
        CP(id_producto)
        Proveedor = id_proveedor, nombre_proveedor
        CP(id_proveedor)
        Contrato = id_contrato, fecha
        CP(id_contrato)
        Suministro = id_producto, id_proveedor, id_contrato, cantidad
        CP(id_producto, id_proveedor, id_contrato)
        C.Aj(id_producto) → Producto
        C.Aj(id_proveedor) → Proveedor
        C.Aj(id_contrato) → Contrato

        ASERCIÓN 1: Producto[id_producto] ⊆ Suministro[id_producto]
        ASERCIÓN 2: Proveedor[id_proveedor] ⊆ Suministro[id_proveedor]
        ASERCIÓN 3: Contrato[id_contrato] ⊆ Suministro[id_contrato]
    </pre>
    <p>Las aserciones aseguran que cada producto, proveedor y contrato participan en la relación de suministro.</p>
</section>

<section id="relaciones_ternarias_existencialidad">
    <h3>Relaciones Ternarias con Restricción de Existencialidad</h3>
    <p>En las relaciones ternarias con existencialidad total, todas las entidades involucradas deben participar en la relación, es decir, cada entidad de los tres conjuntos debe estar relacionada al menos una vez.</p>
    
    <h4>Relación N:M:P con Existencialidad Total</h4>
    <p>En una relación N:M:P, siempre se genera una tabla para la relación que incluye las claves de las tres entidades, además de las aserciones necesarias. Ejemplo: Un producto debe ser suministrado por un proveedor a través de un contrato, y cada contrato debe involucrar a un producto y un proveedor.</p>
    <pre>
        Producto = id_producto, nombre_producto
        CP(id_producto)
        Proveedor = id_proveedor, nombre_proveedor
        CP(id_proveedor)
        Contrato = id_contrato, fecha
        CP(id_contrato)
        Suministro = id_producto, id_proveedor, id_contrato, cantidad
        CP(id_producto, id_proveedor, id_contrato)
        C.Aj(id_producto) → Producto
        C.Aj(id_proveedor) → Proveedor
        C.Aj(id_contrato) → Contrato

        ASERCIÓN 1: Producto[id_producto] ⊆ Suministro[id_producto]
        ASERCIÓN 2: Proveedor[id_proveedor] ⊆ Suministro[id_proveedor]
        ASERCIÓN 3: Contrato[id_contrato] ⊆ Suministro[id_contrato]
    </pre>
    <p>Las aserciones aseguran que cada producto, proveedor y contrato participan en la relación de suministro.</p>
</section>

<section id="normalizacion">
    <h2>Normalización de Bases de Datos</h2>
    <p>La <strong>normalización</strong> es un proceso utilizado en el diseño de bases de datos para organizar los datos de forma que se eviten redundancias y se mantenga la integridad de los datos. Este proceso ayuda a reducir errores y duplicación de datos, mejorando la eficiencia de almacenamiento y la consistencia en las consultas.</p>

    <h3>¿Por qué es importante la normalización?</h3>
    <p>En bases de datos mal estructuradas, es común encontrar información duplicada o inconsistencias debido a datos almacenados en varias tablas. La normalización garantiza:</p>
    <ul>
        <li>Eliminación de redundancias de datos.</li>
        <li>Reducción de problemas de actualización y eliminación de datos.</li>
        <li>Mejor organización para el almacenamiento y acceso a los datos.</li>
    </ul>

    <h3>Primer Paso: Primera Forma Normal (1FN)</h3>
    <p>Para que una tabla esté en <strong>Primera Forma Normal (1FN)</strong>, cada celda debe contener un solo valor (atómicos), y todas las entradas en una columna deben ser del mismo tipo de datos. Esto elimina los valores repetidos y las estructuras complejas en las celdas.</p>
    <h4>Ejemplo:</h4>
    <p>Consideremos una tabla de pedidos antes de aplicar la 1FN:</p>
    <pre>
PedidoID | Cliente     | Productos
---------|-------------|-------------------
1        | Juan Pérez  | ProductoA, ProductoB
2        | Ana López   | ProductoC
3        | Juan Pérez  | ProductoA, ProductoD
    </pre>
    <p>Para cumplir la 1FN, separamos cada producto en filas individuales:</p>
    <pre>
PedidoID | Cliente     | Producto
---------|-------------|---------
1        | Juan Pérez  | ProductoA
1        | Juan Pérez  | ProductoB
2        | Ana López   | ProductoC
3        | Juan Pérez  | ProductoA
3        | Juan Pérez  | ProductoD
    </pre>

    <h3>Segundo Paso: Segunda Forma Normal (2FN)</h3>
    <p>Para estar en <strong>Segunda Forma Normal (2FN)</strong>, la tabla debe cumplir la 1FN y además, todos los atributos no clave deben depender completamente de la clave primaria.</p>
    <h4>Ejemplo:</h4>
    <p>Supongamos que tenemos esta tabla de pedidos, que ya cumple la 1FN:</p>
    <pre>
PedidoID | Producto    | Cliente     | Dirección
---------|-------------|-------------|------------
1        | ProductoA   | Juan Pérez  | C/ Ejemplo, 1
1        | ProductoB   | Juan Pérez  | C/ Ejemplo, 1
2        | ProductoC   | Ana López   | C/ Prueba, 2
    </pre>
    <p>En este caso, la dirección depende del cliente, no del pedido, por lo que movemos el cliente y la dirección a otra tabla.</p>
    <pre>
Clientes:
Cliente     | Dirección
------------|------------
Juan Pérez  | C/ Ejemplo, 1
Ana López   | C/ Prueba, 2

Pedidos:
PedidoID | Producto    | Cliente
---------|-------------|-----------
1        | ProductoA   | Juan Pérez
1        | ProductoB   | Juan Pérez
2        | ProductoC   | Ana López
    </pre>

    <h3>Tercer Paso: Tercera Forma Normal (3FN)</h3>
    <p>Para estar en <strong>Tercera Forma Normal (3FN)</strong>, una tabla debe cumplir la 2FN, y además, todos los atributos no clave deben depender directamente de la clave primaria, sin dependencias transitivas.</p>
    <h4>Ejemplo:</h4>
    <p>Consideremos una tabla de clientes que cumple 2FN:</p>
    <pre>
ClienteID | Nombre      | Dirección        | Ciudad
----------|-------------|------------------|---------
1         | Juan Pérez  | C/ Ejemplo, 1    | Madrid
2         | Ana López   | C/ Prueba, 2     | Sevilla
    </pre>
    <p>Aquí, la ciudad depende de la dirección, no del ClienteID. La tabla se reorganiza en:</p>
    <pre>
Clientes:
ClienteID | Nombre      | DirecciónID
----------|-------------|--------------
1         | Juan Pérez  | 1
2         | Ana López   | 2

Direcciones:
DirecciónID | Dirección       | Ciudad
------------|-----------------|---------
1           | C/ Ejemplo, 1   | Madrid
2           | C/ Prueba, 2    | Sevilla
    </pre>

    <h3>Cuarto Paso: Forma Normal de Boyce-Codd (BCFN)</h3>
    <p>La <strong>Forma Normal de Boyce-Codd (BCFN)</strong> es una versión más estricta de la 3FN. En esta forma, cada dependencia funcional en una tabla debe ser una dependencia de clave.</p>
    <h4>Ejemplo:</h4>
    <p>Imaginemos una tabla de asignación de empleados a proyectos:</p>
    <pre>
EmpleadoID | ProyectoID | SupervisorID
-----------|------------|--------------
1          | 101        | 501
2          | 101        | 501
3          | 102        | 502
    </pre>
    <p>En este caso, cada proyecto tiene un único supervisor, por lo que SupervisorID depende de ProyectoID, no de la clave EmpleadoID + ProyectoID. Para cumplir BCFN, se crea una tabla de proyectos para separar los supervisores:</p>
    <pre>
Proyectos:
ProyectoID | SupervisorID
-----------|--------------
101        | 501
102        | 502

Asignación:
EmpleadoID | ProyectoID
-----------|------------
1          | 101
2          | 101
3          | 102
    </pre>
</section>
        <a href="#arriba" class="back-to-top"> ↑ </a>
    </main>

    <footer>
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="Licencia Creative Commons">
        </a>
    </footer>
</body>
</html>

